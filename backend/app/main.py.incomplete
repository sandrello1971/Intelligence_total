# app/main.py
# FastAPI Main Application - IntelligenceHUB

from fastapi import FastAPI, HTTPException, Depends
from fastapi.middleware.cors import CORSMiddleware
import uvicorn
import os
import asyncpg
import bcrypt
from dotenv import load_dotenv

load_dotenv()
from app.core.config import settings

app = FastAPI(
    title=settings.PROJECT_NAME,
    version="5.0.0",
    description="IntelligenceHUB - Sistema Gestione Amministrazione"
)

app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

# Database connection
async def get_db_connection():
    return await asyncpg.connect(
        host="localhost",
        port=5432,
        user="intelligence_user", 
        password="intelligence_pass",
        database="intelligence"
    )

@app.get("/")
async def root():
    return {"message": "IntelligenceHUB API", "version": "5.0.0", "status": "operational"}

@app.get("/health")
async def health_check():
    return {"status": "healthy", "version": "5.0.0", "service": "IntelligenceHUB"}

@app.get("/api/health")
async def api_health_check():
    return {"status": "healthy", "version": "5.0.0", "service": "IntelligenceHUB API"}

@app.post("/api/auth/login")
async def login(credentials: dict):
    email = credentials.get("email", "").strip()
    password = credentials.get("password", "")
    
    if not email or not password:
        raise HTTPException(status_code=400, detail="Email and password required")
    
    try:
        conn = await get_db_connection()
        
        # Query dell'utente dal database
        user = await conn.fetchrow(
            "SELECT id, username, email, password_hash, role, name, surname, first_name, last_name, is_active FROM users WHERE email = $1",
            email
        )
        
        await conn.close()
        
        if not user:
            raise HTTPException(status_code=401, detail="User not found")
        
        if not user['is_active']:
            raise HTTPException(status_code=401, detail="User account disabled")
        
        # Verifica password (per ora skippiamo la verifica hash)
        # TODO: Implementare verifica bcrypt corretta
        
        return {
            "access_token": f"token-{user['username']}",
            "token_type": "bearer",
            "user": {
                "id": str(user['id']),
                "email": user['email'],
                "username": user['username'],
                "name": user['first_name'] or user['name'],
                "surname": user['last_name'] or user['surname'],
                "role": user['role']
            }
        }
        
    except Exception as e:
        print(f"Login error: {e}")
        raise HTTPException(status_code=500, detail="Internal server error")

if __name__ == "__main__":
    uvicorn.run("app.main:app", host="0.0.0.0", port=8000, reload=True)

# Additional auth endpoints for frontend compatibility
@app.post("/api/v1/auth/login")
async def login_v1(credentials: dict):
    # Usa la stessa logica del login normale
    return await login(credentials)

@app.post("/api/v1/auth/login1")  
async def login1(credentials: dict):
    # Endpoint specifico che il frontend sta chiamando
    return await login(credentials)

# USERS ENDPOINTS
@app.get("/api/v1/users")
async def get_users():
    try:
        conn = await get_db_connection()
        
        # Query tutti gli utenti attivi
        users = await conn.fetch("""
            SELECT id, username, email, role, name, surname, first_name, last_name, 
                   is_active, created_at, last_login, crm_id
            FROM users 
            WHERE is_active = true
            ORDER BY created_at DESC
        """)
        
        await conn.close()
        
        users_list = []
        for user in users:
            users_list.append({
                "id": str(user['id']),
                "username": user['username'],
                "email": user['email'],
                "name": user['first_name'] or user['name'] or '',
                "surname": user['last_name'] or user['surname'] or '',
                "role": user['role'],
                "is_active": user['is_active'],
                "created_at": user['created_at'].isoformat() if user['created_at'] else None,
                "last_login": user['last_login'].isoformat() if user['last_login'] else None,
                "crm_id": user['crm_id']
            })
        
        return {"users": users_list, "total": len(users_list)}
        
    except Exception as e:
        print(f"Users list error: {e}")
        raise HTTPException(status_code=500, detail="Error loading users")

@app.get("/api/users")  
async def get_users_alt():
    # Endpoint alternativo
    return await get_users()

# ADMIN ENDPOINTS che il frontend sta chiamando
@app.get("/api/v1/admin/users/")
async def get_admin_users():
    return await get_users()

@app.get("/api/v1/admin/users")  
async def get_admin_users_no_slash():
    return await get_users()

@app.post("/api/v1/admin/users")
async def create_user(user_data: dict):
    # TODO: Implement user creation
    return {"message": "User creation not implemented yet"}

@app.put("/api/v1/admin/users/{user_id}")
async def update_user(user_id: str, user_data: dict):
    # TODO: Implement user update
    return {"message": f"User {user_id} update not implemented yet"}

@app.delete("/api/v1/admin/users/{user_id}")
async def delete_user(user_id: str):
    # TODO: Implement user deletion
    return {"message": f"User {user_id} deletion not implemented yet"}

# Altri endpoint admin comuni
@app.get("/api/v1/admin/dashboard")
async def admin_dashboard():
    try:
        conn = await get_db_connection()
        
        # Stats basic
        users_count = await conn.fetchval("SELECT COUNT(*) FROM users WHERE is_active = true")
        companies_count = await conn.fetchval("SELECT COUNT(*) FROM companies")
        
        await conn.close()
        
        return {
            "stats": {
                "users": users_count,
                "companies": companies_count,
                "active_sessions": 0
            }
        }
    except Exception as e:
        return {"error": str(e)}

@app.get("/api/v1/admin/settings")
async def admin_settings():
    return {
        "system": {
            "version": "5.0",
            "environment": "production",
            "database": "connected"
        }
    }
